{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.7843866171003717,
      "layerName": "Waffle",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0.02,
      "anchorPoint": "center",
      "mouseMomentum": 0.16,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0.25,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "image",
      "imageLoaded": false,
      "width": 450,
      "widthMode": "fixed",
      "height": 252.1875,
      "heightMode": "auto",
      "left": 0.5,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fitToCanvas": 1,
      "exposure": 0,
      "saturation": 1,
      "contrast": 1,
      "src": "https://assets.unicorn.studio/images/FxrjnLd8G6TvOrlhuIr4whrvobB2/Waffle-Foreground%20(1).webp",
      "naturalWidth": 1920,
      "naturalHeight": 1076,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform int uSampleBg;const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.2500); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) { color = mix(background, color + background * (1.0 - color.a), 1.0000); return color; }vec4 getOutputByMode(vec4 color, vec4 background) { return getNormalOutput(color, background); }void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0200);uv = perspectiveUV(uv) - pos;uv -= pos;vec4 background = vec4(0); if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0) * color.a;vec4 col = getOutputByMode(color, background);fragColor = col; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "wisps",
      "usesPingPong": false,
      "speed": 0.54,
      "trackMouse": 0.02,
      "trackAxes": "x",
      "mouseMomentum": 0.2,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) { vec2 i_st = floor(st); vec2 f_st = fract(st);float wander = 0.2400 * uTime * 0.2; float total_contribution = 0.0;for (int y = -2; y <= 2; y++) { for (int x = -2; x <= 2; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 cell_id = i_st + neighbor; vec2 point = hash(cell_id); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 starAbsPos = cell_id + point; vec2 dirToMouse = mouse_pos - starAbsPos; float distToMouse = length(dirToMouse); float attractStrength = 0.1900 * exp(-distToMouse * mix(2.0 + 0.5820 * 2., 0.5, 0.5000)) * 2.; starAbsPos += dirToMouse * attractStrength; vec2 diff = starAbsPos - st; float dist = length(diff);float contribution = radius / max(dist, radius * 0.1); float shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5; float shimmer = mix(1., (sin(shimmer_phase) + 1.), 0.5000); contribution *= shimmer; total_contribution += mix(contribution*contribution, contribution * 2., 0.1100); } }return total_contribution; }vec4 randomStyle() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0); vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.0200);uv -= vec2(0.5, 0.5); uv *= aspectRatio; uv = uv * rot(0.5000 * 2.0 * PI); uv *= 40.0 * 0.5820; uv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.0000); uv /= aspectRatio;mPos = mPos * rot(0.5000 * 2.0 * PI);vec2 mouseGrid = uMousePos; mouseGrid -= vec2(0.5, 0.5); mouseGrid *= aspectRatio; mouseGrid = mouseGrid * rot(0.5000 * 2.0 * PI); mouseGrid *= 40.0 * 0.5820; mouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.0000); mouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 0.5820) + movementOffset; vec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 0.5820) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 0.5820); vec2 st2 = uv - (mPos * 48.0 * 0.5820);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouse2 = st2 + vec2(0.0, uTime * 0.5000 * -0.05);float radius1 = 0.5 * 0.4100; float radius2 = 0.5 * 0.4100;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 0.5820); float pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 0.5820);pass1 *= 0.02; pass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1.0, bg.r, 1.0000); color.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); return color; }void main() { vec4 color;color = randomStyle(); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "spotlight",
      "usesPingPong": false,
      "trackMouse": 0.25,
      "trackAxes": "xy",
      "mouseMomentum": 0.1,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.2200 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(1, 0)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.2200 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(0, 1)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const int kernelSize = 36;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return luma(col.rgb); }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 0.2200) / ste, 2.)), height); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }vec4 getPointlight(vec2 uv) { vec2 pos = vec2(0.5033519553072625, 0.5697206703910614) + mix(vec2(0), (uMousePos-0.5), 0.2500); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec4 color = texture(uBgTexture, uv); float lum = luma(color.rgb); float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.2500 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.2500 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb * lum; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.3500 * 3.; vec3 base = color.rgb * vec3(1, 1, 1) * max(0., spot) * intensity; color.rgb = color.rgb * 1.0000 + base * diff * vec3(1, 1, 1) * max(0., spot) * intensity; color.rgb += specular * vec3(1, 1, 1) * max(0., spot * 4.) * 0.1900; color.rgb = Tonemap_tanh(color.rgb); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 getColor(vec2 uv) { return getPointlight(uv); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "pass", "value": 1, "downSample": 0.5 },
          { "prop": "pass", "value": 2, "includeBg": true }
        ]
      },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "godrays",
      "usesPingPong": false,
      "trackMouse": 0.15,
      "trackAxes": "xy",
      "mouseMomentum": 0.05,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.2900 - 0.1, 0.2900, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.2500)) * stepFactor; vec2 pos = vec2(0.4977653631284916, 0.5607821229050279) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.1500); float weight = 1.0; float bnoz = randFibo(st) * 0.2500; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.2500; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.8300 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.3000 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(1, 1, 1); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.3000 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "pass", "value": 1, "downSample": 0.5 },
          { "prop": "pass", "value": 2, "includeBg": true }
        ],
        "texture": {
          "src": "https://assets.unicorn.studio/media/blue_noise_med.png",
          "sampler": "uBlueNoise"
        }
      },
      "id": "effect2"
    }
  ],
  "options": {
    "name": "Waffle Hero",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.35",
  "id": "2x4ApZ4YPWD0SO3rPcvH"
}
